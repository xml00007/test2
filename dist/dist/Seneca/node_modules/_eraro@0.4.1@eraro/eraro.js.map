{"version":3,"sources":["../../../../Seneca/node_modules/_eraro@0.4.1@eraro/eraro.js"],"names":["util","require","_","module","exports","eraro","options","msgprefix","prefix","isString","package","packaje","callmodule","msgmap","inspect","markers","filename","push","errormaker","ex","code","msg","details","internalex","isError","override","arguments","message","isObject","buildmessage","err","Error","orig$","message$","p","orig","stack","callpoint","error","isArray","out","lines","split","done","i","line_loop","length","line","found","j","indexOf","substring","originalmsg","valmap","extend","valstrmap","each","val","key","eval","e","tm","template","ReferenceError","m","exec","toString","depth"],"mappings":"AAAA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,IAAIA,OAAOC,QAAQ,MAAR,CAAX;;AAEA;AACA,IAAIC,IAAID,QAAQ,QAAR,CAAR;;AAEA;AACAE,OAAOC,OAAP,GAAiBC,KAAjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,KAAT,CAAeC,OAAf,EAAwB;AACtBA,YAAUA,WAAW,EAArB;;AAEA,MAAIC,YAAY,UAAUD,QAAQE,MAAlB,GAA2B,EAA3B,GAAgCN,EAAEO,QAAF,CAAWH,QAAQE,MAAnB,IAA6BF,QAAQE,MAArC,GAA8CN,EAAEO,QAAF,CAAWH,QAAQI,OAAnB,IAA8BJ,QAAQI,OAAR,GAAkB,IAAhD,GAAuD,EAArJ;;AAEA,MAAIC,UAAUL,QAAQI,OAAR,IAAmB,SAAjC;AACA,MAAIE,aAAaN,QAAQH,MAAR,IAAkBA,MAAnC;AACA,MAAIU,SAASP,QAAQO,MAAR,IAAkB,EAA/B;AACA,MAAIC,UAAU,QAAQR,QAAQQ,OAAhB,GAA0B,IAA1B,GAAiC,CAAC,CAACR,QAAQQ,OAAzD;;AAEA,MAAIC,UAAU,CAACZ,OAAOa,QAAR,CAAd;;AAEA,MAAIA,WAAWJ,WAAWI,QAA1B;AACA,MAAIA,QAAJ,EAAcD,QAAQE,IAAR,CAAaD,QAAb;;AAEd,MAAIE,aAAa,SAASA,UAAT,CAAoBC,EAApB,EAAwBC,IAAxB,EAA8BC,GAA9B,EAAmCC,OAAnC,EAA4C;AAC3D,QAAIC,aAAa,KAAjB;;AAEA,QAAIvB,KAAKwB,OAAL,CAAaL,EAAb,CAAJ,EAAsB;AACpB,UAAIA,GAAGd,KAAH,IAAY,CAACC,QAAQmB,QAAzB,EAAmC,OAAON,EAAP;AACpC,KAFD,MAEO;AACLI,mBAAa,IAAb;AACAJ,WAAK,IAAL;AACAC,aAAOM,UAAU,CAAV,CAAP;AACAL,YAAMK,UAAU,CAAV,CAAN;AACAJ,gBAAUI,UAAU,CAAV,CAAV;AACD;;AAEDN,WAAOlB,EAAEO,QAAF,CAAWW,IAAX,IAAmBA,IAAnB,GAA0BD,KAAKA,GAAGC,IAAH,GAAUD,GAAGC,IAAb,GAAoBD,GAAGQ,OAAH,GAAaR,GAAGQ,OAAhB,GAA0B,SAAnD,GAA+D,SAAhG;;AAEAL,cAAUpB,EAAE0B,QAAF,CAAWN,OAAX,IAAsBA,OAAtB,GAAgCpB,EAAE0B,QAAF,CAAWP,GAAX,KAAmB,CAACnB,EAAEO,QAAF,CAAWY,GAAX,CAApB,GAAsCA,GAAtC,GAA4C,EAAtF;;AAEAA,UAAMnB,EAAEO,QAAF,CAAWY,GAAX,IAAkBA,GAAlB,GAAwB,IAA9B;AACAA,UAAMQ,aAAavB,OAAb,EAAsBe,GAAtB,EAA2BR,MAA3B,EAAmCN,SAAnC,EAA8CO,OAA9C,EAAuDM,IAAvD,EAA6DE,OAA7D,EAAsEH,EAAtE,CAAN;;AAEA,QAAIW,MAAM,IAAIC,KAAJ,CAAUV,GAAV,CAAV;;AAEA,QAAIF,EAAJ,EAAQ;AACNG,cAAQU,KAAR,GAAgB,QAAQV,QAAQU,KAAhB,GAAwBb,EAAxB,GAA6BG,QAAQU,KAArD;AACAV,cAAQW,QAAR,GAAmB,QAAQX,QAAQW,QAAhB,GAA2Bd,GAAGQ,OAA9B,GAAwCL,QAAQW,QAAnE;;AAEA;AACA,WAAK,IAAIC,CAAT,IAAcf,EAAd,EAAkB;AAChBW,YAAII,CAAJ,IAASf,GAAGe,CAAH,CAAT;AACD;AACF;;AAEDJ,QAAIzB,KAAJ,GAAY,IAAZ;;AAEAyB,QAAIK,IAAJ,GAAWhB,EAAX,CAlC2D,CAkC5C;AACfW,QAAIV,IAAJ,GAAWA,IAAX;AACAU,QAAInB,OAAJ,IAAe,IAAf;AACAmB,QAAIpB,OAAJ,GAAcC,OAAd;AACAmB,QAAIT,GAAJ,GAAUA,GAAV;AACAS,QAAIR,OAAJ,GAAcA,OAAd;;AAEAQ,QAAIM,KAAJ,GAAYjB,KAAKA,GAAGiB,KAAR,GAAgBN,IAAIM,KAAhC;AACAN,QAAIO,SAAJ,GAAgBA,UAAUP,GAAV,EAAef,OAAf,CAAhB;;AAEA,WAAOe,GAAP;AACD,GA7CD;;AA+CAZ,aAAWmB,SAAX,GAAuBA,SAAvB;;AAEA,SAAOnB,UAAP;AACD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASmB,SAAT,CAAmBC,KAAnB,EAA0BvB,OAA1B,EAAmC;AACjCA,YAAUb,EAAEqC,OAAF,CAAUxB,OAAV,IAAqBA,OAArB,GAA+B,EAAzC;;AAEA,MAAIqB,QAAQE,QAAQA,MAAMF,KAAd,GAAsB,IAAlC;AACA,MAAII,MAAM,EAAV;;AAEA,MAAIJ,KAAJ,EAAW;AACT,QAAIK,QAAQL,MAAMM,KAAN,CAAY,IAAZ,CAAZ;AACA,QAAIC,OAAO,KAAX;AACA,QAAIC,UAAJ;;AAEAC,eAAW,KAAKD,IAAI,CAAT,EAAYA,IAAIH,MAAMK,MAAtB,EAA8BF,GAA9B,EAAmC;AAC5C,UAAIG,OAAON,MAAMG,CAAN,CAAX;;AAEA,UAAII,QAAQ,KAAZ;AACA,WAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIlC,QAAQ+B,MAA5B,EAAoCG,GAApC,EAAyC;AACvC,YAAI/C,EAAEO,QAAF,CAAWM,QAAQkC,CAAR,CAAX,CAAJ,EAA4B;AAC1BD,kBAAQ,CAAC,CAAD,IAAMD,KAAKG,OAAL,CAAanC,QAAQkC,CAAR,CAAb,CAAd;AACA,cAAID,KAAJ,EAAW;AACZ;AACF;;AAED,UAAI,CAACA,KAAL,EAAY,MAAMH,SAAN;AACb;;AAEDL,UAAMtC,EAAEO,QAAF,CAAWgC,MAAMG,CAAN,CAAX,IAAuBH,MAAMG,CAAN,EAASO,SAAT,CAAmB,CAAnB,CAAvB,GAA+CX,GAArD;AACD;;AAED,SAAOA,GAAP;AACD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASX,YAAT,CAAsBvB,OAAtB,EAA+Be,GAA/B,EAAoCR,MAApC,EAA4CN,SAA5C,EAAuDO,OAAvD,EAAgEM,IAAhE,EAAsEE,OAAtE,EAA+EH,EAA/E,EAAmF;AACjF,MAAIQ,UAAUpB,aAAaL,EAAEO,QAAF,CAAWY,GAAX,IAAkBA,GAAlB,GAAwBnB,EAAEO,QAAF,CAAWI,OAAOO,IAAP,CAAX,IAA2BP,OAAOO,IAAP,CAA3B,GAA0CD,KAAKiC,YAAY9C,QAAQmB,QAApB,EAA8BN,EAA9B,CAAL,GAAyCC,IAAxH,CAAd;;AAEA;AACA,MAAIiC,SAASnD,EAAEoD,MAAF,CAAS,EAAT,EAAahC,OAAb,EAAsB,EAAEF,MAAMA,IAAR,EAAtB,CAAb;;AAEA;AACA;AACA;;AAEA,MAAImC,YAAY,EAAEvD,MAAMA,IAAR,EAAcE,GAAGA,CAAjB,EAAhB;AACAA,IAAEsD,IAAF,CAAOH,MAAP,EAAe,UAAUI,GAAV,EAAeC,GAAf,EAAoB;AACjC;AACA,QAAI;AACFC,WAAK,SAASD,GAAT,GAAe,GAApB;AACD,KAFD,CAEE,OAAOE,CAAP,EAAU;AACVF,YAAMA,MAAM,GAAZ;AACD;AACD,QAAI,EAAE,aAAa,CAAf,EAAkB,OAAO,CAAzB,GAA6BA,GAA7B,CAAJ,EAAuC;AACrCA,YAAMA,MAAM,GAAZ;AACD;AACDH,cAAUG,GAAV,IAAiB5C,WAAW,CAACZ,EAAEO,QAAF,CAAWgD,GAAX,CAAZ,GAA8BzD,KAAKc,OAAL,CAAa2C,GAAb,CAA9B,GAAkDA,GAAnE;AACD,GAXD;;AAaA,MAAId,OAAO,KAAX;AACA,SAAO,CAACA,IAAR,EAAc;AACZ,QAAI;AACF,UAAIkB,KAAK3D,EAAE4D,QAAF,CAAWnC,OAAX,CAAT;AACAA,gBAAUkC,GAAGN,SAAH,CAAV;AACAZ,aAAO,IAAP;AACD,KAJD,CAIE,OAAOiB,CAAP,EAAU;AACV,UAAIA,aAAaG,cAAjB,EAAiC;AAC/B,YAAIC,IAAI,6BAA6BC,IAA7B,CAAkCL,EAAEM,QAAF,EAAlC,CAAR;AACA,YAAIF,KAAKA,EAAE,CAAF,CAAT,EAAe;AACbT,oBAAUS,EAAE,CAAF,CAAV,IAAkB,MAAMA,EAAE,CAAF,CAAN,GAAa,IAA/B;AACD,SAFD,MAEOrB,OAAO,IAAP;AACR;;AAED;AACA;AARA,WASK;AACDA,iBAAO,IAAP;AACAhB,oBAAUA,UAAU,UAAV,GAAuB3B,KAAKc,OAAL,CAAauC,MAAb,EAAqB,EAAEc,OAAO,CAAT,EAArB,CAAvB,GAA4D,mBAA5D,GAAkFP,CAA5F;AACD;AACJ;AACF;;AAED,SAAOjC,OAAP;AACD;;AAED,SAASyB,WAAT,CAAqB3B,QAArB,EAA+BN,EAA/B,EAAmC;AACjC,MAAI,CAACA,EAAL,EAAS;;AAET,MAAIM,YAAYN,GAAGd,KAAf,IAAwBc,GAAGgB,IAA/B,EAAqC,OAAOhB,GAAGgB,IAAH,CAAQR,OAAf;;AAErC,SAAOR,GAAGQ,OAAV;AACD;AACD","file":"eraro.js","sourcesContent":["/* Copyright (c) 2014-2015 Richard Rodger, MIT License */\n/* jshint node:true, asi:true, eqnull:true */\n\n// Create JavaScript Error objects with code strings, context details,\n// and templated messages.\n\"use strict\";\n\n// #### System modules\n\nlet util = require('util');\n\n// #### External modules\nlet _ = require('lodash');\n\n// #### Exports\nmodule.exports = eraro;\n\n// #### Create an _eraro_ function\n// Parameters:\n// \n//   * _options_ : (optional) Object; properties:\n//      * _package_ : (optional) String; package name to mark Error objects\n//      * _prefix_  : (optional) Boolean/String; If false, then no prefix is used; If not defined, the package name is used\n//      * _module_  : (optional) Object; _module_ object to use as starting point for _require_ calls\n//      * _msgmap_  : (optional) Object; map codes to message templates \n//      * _inspect_ : (optional) Boolean; If true, _util.inspect_ is called on values; default: true.\n//\n// Returns: Function\n//\n// The created function has parameters:\n//  \n//   * _exception_ : (optional) Error; the original exception to be wrapped\n//   * _code_ : (optional) String; code value\n//   * _message_ : (optional) String; error message, will be processed as a template\n//   * _details_ : (optional) Object; contextual details of the error, used to insert details into message\n//\n// and returns an Error object (to be thrown or used in a callback, as needed).\n// The returned Error object has the following additional properties:\n//   \n//   * _code_: String; the code string\n//   * _package_: String; the package name\n//   * _**package-name**_: Boolean (true); a convenience marker for the package\n//   * _msg_: String; the generated message, may differ from original exception message (if any)\n//   * _details_: Object; contextual details of error\n//   * _callpoint_: String; first line of stacktrace that is external to eraro and calling module \nfunction eraro(options) {\n  options = options || {};\n\n  let msgprefix = false === options.prefix ? '' : _.isString(options.prefix) ? options.prefix : _.isString(options.package) ? options.package + ': ' : '';\n\n  let packaje = options.package || 'unknown';\n  let callmodule = options.module || module;\n  let msgmap = options.msgmap || {};\n  let inspect = null == options.inspect ? true : !!options.inspect;\n\n  let markers = [module.filename];\n\n  let filename = callmodule.filename;\n  if (filename) markers.push(filename);\n\n  let errormaker = function errormaker(ex, code, msg, details) {\n    let internalex = false;\n\n    if (util.isError(ex)) {\n      if (ex.eraro && !options.override) return ex;\n    } else {\n      internalex = true;\n      ex = null;\n      code = arguments[0];\n      msg = arguments[1];\n      details = arguments[2];\n    }\n\n    code = _.isString(code) ? code : ex ? ex.code ? ex.code : ex.message ? ex.message : 'unknown' : 'unknown';\n\n    details = _.isObject(details) ? details : _.isObject(msg) && !_.isString(msg) ? msg : {};\n\n    msg = _.isString(msg) ? msg : null;\n    msg = buildmessage(options, msg, msgmap, msgprefix, inspect, code, details, ex);\n\n    let err = new Error(msg);\n\n    if (ex) {\n      details.orig$ = null == details.orig$ ? ex : details.orig$;\n      details.message$ = null == details.message$ ? ex.message : details.message$;\n\n      // drag along properties from original exception\n      for (let p in ex) {\n        err[p] = ex[p];\n      }\n    }\n\n    err.eraro = true;\n\n    err.orig = ex; // orig\n    err.code = code;\n    err[packaje] = true;\n    err.package = packaje;\n    err.msg = msg;\n    err.details = details;\n\n    err.stack = ex ? ex.stack : err.stack;\n    err.callpoint = callpoint(err, markers);\n\n    return err;\n  };\n\n  errormaker.callpoint = callpoint;\n\n  return errormaker;\n}\n\n// #### Find the first external stack trace line.\n// Parameters:\n// \n//   * _error_ : (optional) Error; provides the stack\n//   * _markers_ : (optional) Array[String]; ignore lines containing these strings\n//\n// Returns: String; stack trace line, with indent removed\nfunction callpoint(error, markers) {\n  markers = _.isArray(markers) ? markers : [];\n\n  let stack = error ? error.stack : null;\n  let out = '';\n\n  if (stack) {\n    let lines = stack.split('\\n');\n    let done = false;\n    let i;\n\n    line_loop: for (i = 1; i < lines.length; i++) {\n      let line = lines[i];\n\n      let found = false;\n      for (let j = 0; j < markers.length; j++) {\n        if (_.isString(markers[j])) {\n          found = -1 != line.indexOf(markers[j]);\n          if (found) break;\n        }\n      }\n\n      if (!found) break line_loop;\n    }\n\n    out = _.isString(lines[i]) ? lines[i].substring(4) : out;\n  }\n\n  return out;\n}\n\n// #### Build the message string from a template by inserting details\n// Uses the underscore template function with default settings. \n// The original message (_msg_) has priority over messages from the _msgmap_.\n// If no message can be found, the _code_ is used as a message.\n// If an insert property is not defined, it is replaced with _[name?]_ in the message.\n// As a convenience, _util_ and ___ are made available in the templates.\n//\n// Parameters:\n// \n//   * _msg_ : (required) String; message template\n//   * _msgmap_ : (required) Object; map codes to message templates\n//   * _msgprefix_: (required) String; prefix for all messages, useful as indentification of error origin\n//   * _code_: (required) String; error code\n//   * _details_: (required) Object; error details providing context\n//\n// Returns: String; human readable error message\nfunction buildmessage(options, msg, msgmap, msgprefix, inspect, code, details, ex) {\n  let message = msgprefix + (_.isString(msg) ? msg : _.isString(msgmap[code]) ? msgmap[code] : ex ? originalmsg(options.override, ex) : code);\n\n  // These are the inserts.\n  let valmap = _.extend({}, details, { code: code });\n\n  // Workaround to prevent underscore blowing up if properties are not\n  // found.  Reserved words and undefined need to be suffixed with $\n  // in the template interpolates.\n\n  let valstrmap = { util: util, _: _ };\n  _.each(valmap, function (val, key) {\n    /* jshint evil:true */\n    try {\n      eval('let ' + key + ';');\n    } catch (e) {\n      key = key + '$';\n    }\n    if ({ 'undefined': 1, 'NaN': 1 }[key]) {\n      key = key + '$';\n    }\n    valstrmap[key] = inspect && !_.isString(val) ? util.inspect(val) : val;\n  });\n\n  let done = false;\n  while (!done) {\n    try {\n      let tm = _.template(message);\n      message = tm(valstrmap);\n      done = true;\n    } catch (e) {\n      if (e instanceof ReferenceError) {\n        let m = /ReferenceError:\\s+(.*?)\\s+/.exec(e.toString());\n        if (m && m[1]) {\n          valstrmap[m[1]] = \"[\" + m[1] + \"?]\";\n        } else done = true;\n      }\n\n      // Some other error - give up and just dump the properties at\n      // the end of the template.\n      else {\n          done = true;\n          message = message + ' VALUES:' + util.inspect(valmap, { depth: 2 }) + ' TEMPLATE ERROR: ' + e;\n        }\n    }\n  }\n\n  return message;\n}\n\nfunction originalmsg(override, ex) {\n  if (!ex) return;\n\n  if (override && ex.eraro && ex.orig) return ex.orig.message;\n\n  return ex.message;\n}\n//# sourceMappingURL=eraro.js.map"]}