{"version":3,"sources":["../../../../../../../Seneca/node_modules/_gex@0.2.2@gex/node_modules/lodash/internal/composeArgsRight.js"],"names":["nativeMax","Math","max","composeArgsRight","args","partials","holders","holdersIndex","holdersLength","length","argsIndex","argsLength","rightIndex","rightLength","result","Array","offset","module","exports"],"mappings":"AAAA;;AAEA;;AACA,IAAIA,YAAYC,KAAKC,GAArB;;AAEA;;;;;;;;;;AAUA,SAASC,gBAAT,CAA0BC,IAA1B,EAAgCC,QAAhC,EAA0CC,OAA1C,EAAmD;AACjD,MAAIC,eAAe,CAAC,CAApB;AAAA,MACIC,gBAAgBF,QAAQG,MAD5B;AAAA,MAEIC,YAAY,CAAC,CAFjB;AAAA,MAGIC,aAAaX,UAAUI,KAAKK,MAAL,GAAcD,aAAxB,EAAuC,CAAvC,CAHjB;AAAA,MAIII,aAAa,CAAC,CAJlB;AAAA,MAKIC,cAAcR,SAASI,MAL3B;AAAA,MAMIK,SAASC,MAAMJ,aAAaE,WAAnB,CANb;;AAQA,SAAO,EAAEH,SAAF,GAAcC,UAArB,EAAiC;AAC/BG,WAAOJ,SAAP,IAAoBN,KAAKM,SAAL,CAApB;AACD;AACD,MAAIM,SAASN,SAAb;AACA,SAAO,EAAEE,UAAF,GAAeC,WAAtB,EAAmC;AACjCC,WAAOE,SAASJ,UAAhB,IAA8BP,SAASO,UAAT,CAA9B;AACD;AACD,SAAO,EAAEL,YAAF,GAAiBC,aAAxB,EAAuC;AACrCM,WAAOE,SAASV,QAAQC,YAAR,CAAhB,IAAyCH,KAAKM,WAAL,CAAzC;AACD;AACD,SAAOI,MAAP;AACD;;AAEDG,OAAOC,OAAP,GAAiBf,gBAAjB;AACA","file":"composeArgsRight.js","sourcesContent":["\"use strict\";\n\n/* Native method references for those with the same name as other `lodash` methods. */\nlet nativeMax = Math.max;\n\n/**\n * This function is like `composeArgs` except that the arguments composition\n * is tailored for `_.partialRight`.\n *\n * @private\n * @param {Array|Object} args The provided arguments.\n * @param {Array} partials The arguments to append to those provided.\n * @param {Array} holders The `partials` placeholder indexes.\n * @returns {Array} Returns the new array of composed arguments.\n */\nfunction composeArgsRight(args, partials, holders) {\n  let holdersIndex = -1,\n      holdersLength = holders.length,\n      argsIndex = -1,\n      argsLength = nativeMax(args.length - holdersLength, 0),\n      rightIndex = -1,\n      rightLength = partials.length,\n      result = Array(argsLength + rightLength);\n\n  while (++argsIndex < argsLength) {\n    result[argsIndex] = args[argsIndex];\n  }\n  let offset = argsIndex;\n  while (++rightIndex < rightLength) {\n    result[offset + rightIndex] = partials[rightIndex];\n  }\n  while (++holdersIndex < holdersLength) {\n    result[offset + holders[holdersIndex]] = args[argsIndex++];\n  }\n  return result;\n}\n\nmodule.exports = composeArgsRight;\n//# sourceMappingURL=composeArgsRight.js.map"]}