{"version":3,"sources":["../../../../../../../Seneca/node_modules/_gex@0.2.2@gex/node_modules/lodash/function/debounce.js"],"names":["isObject","require","now","FUNC_ERROR_TEXT","nativeMax","Math","max","debounce","func","wait","options","args","maxTimeoutId","result","stamp","thisArg","timeoutId","trailingCall","lastCalled","maxWait","trailing","TypeError","leading","cancel","clearTimeout","undefined","complete","isCalled","id","apply","delayed","remaining","setTimeout","maxDelayed","debounced","arguments","leadingCall","module","exports"],"mappings":"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","file":"debounce.js","sourcesContent":["var isObject = require('../lang/isObject'),\n    now = require('../date/now');\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed invocations. Provide an options object to indicate that `func`\n * should be invoked on the leading and/or trailing edge of the `wait` timeout.\n * Subsequent calls to the debounced function return the result of the last\n * `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\n * on the trailing edge of the timeout only if the the debounced function is\n * invoked more than once during the `wait` timeout.\n *\n * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options] The options object.\n * @param {boolean} [options.leading=false] Specify invoking on the leading\n *  edge of the timeout.\n * @param {number} [options.maxWait] The maximum time `func` is allowed to be\n *  delayed before it is invoked.\n * @param {boolean} [options.trailing=true] Specify invoking on the trailing\n *  edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // avoid costly calculations while the window size is in flux\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // invoke `sendMail` when the click event is fired, debouncing subsequent calls\n * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // ensure `batchLog` is invoked once after 1 second of debounced calls\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', _.debounce(batchLog, 250, {\n *   'maxWait': 1000\n * }));\n *\n * // cancel a debounced call\n * var todoChanges = _.debounce(batchLog, 1000);\n * Object.observe(models.todo, todoChanges);\n *\n * Object.observe(models, function(changes) {\n *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {\n *     todoChanges.cancel();\n *   }\n * }, ['delete']);\n *\n * // ...at some point `models.todo` is changed\n * models.todo.completed = true;\n *\n * // ...before 1 second has passed `models.todo` is deleted\n * // which cancels the debounced `todoChanges` call\n * delete models.todo;\n */\nfunction debounce(func, wait, options) {\n  var args,\n      maxTimeoutId,\n      result,\n      stamp,\n      thisArg,\n      timeoutId,\n      trailingCall,\n      lastCalled = 0,\n      maxWait = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = wait < 0 ? 0 : (+wait || 0);\n  if (options === true) {\n    var leading = true;\n    trailing = false;\n  } else if (isObject(options)) {\n    leading = !!options.leading;\n    maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function cancel() {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n    if (maxTimeoutId) {\n      clearTimeout(maxTimeoutId);\n    }\n    lastCalled = 0;\n    maxTimeoutId = timeoutId = trailingCall = undefined;\n  }\n\n  function complete(isCalled, id) {\n    if (id) {\n      clearTimeout(id);\n    }\n    maxTimeoutId = timeoutId = trailingCall = undefined;\n    if (isCalled) {\n      lastCalled = now();\n      result = func.apply(thisArg, args);\n      if (!timeoutId && !maxTimeoutId) {\n        args = thisArg = undefined;\n      }\n    }\n  }\n\n  function delayed() {\n    var remaining = wait - (now() - stamp);\n    if (remaining <= 0 || remaining > wait) {\n      complete(trailingCall, maxTimeoutId);\n    } else {\n      timeoutId = setTimeout(delayed, remaining);\n    }\n  }\n\n  function maxDelayed() {\n    complete(trailing, timeoutId);\n  }\n\n  function debounced() {\n    args = arguments;\n    stamp = now();\n    thisArg = this;\n    trailingCall = trailing && (timeoutId || !leading);\n\n    if (maxWait === false) {\n      var leadingCall = leading && !timeoutId;\n    } else {\n      if (!maxTimeoutId && !leading) {\n        lastCalled = stamp;\n      }\n      var remaining = maxWait - (stamp - lastCalled),\n          isCalled = remaining <= 0 || remaining > maxWait;\n\n      if (isCalled) {\n        if (maxTimeoutId) {\n          maxTimeoutId = clearTimeout(maxTimeoutId);\n        }\n        lastCalled = stamp;\n        result = func.apply(thisArg, args);\n      }\n      else if (!maxTimeoutId) {\n        maxTimeoutId = setTimeout(maxDelayed, remaining);\n      }\n    }\n    if (isCalled && timeoutId) {\n      timeoutId = clearTimeout(timeoutId);\n    }\n    else if (!timeoutId && wait !== maxWait) {\n      timeoutId = setTimeout(delayed, wait);\n    }\n    if (leadingCall) {\n      isCalled = true;\n      result = func.apply(thisArg, args);\n    }\n    if (isCalled && !timeoutId && !maxTimeoutId) {\n      args = thisArg = undefined;\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  return debounced;\n}\n\nmodule.exports = debounce;\n"]}