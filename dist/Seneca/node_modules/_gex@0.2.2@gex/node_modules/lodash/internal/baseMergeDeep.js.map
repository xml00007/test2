{"version":3,"sources":["../../../../../../../Seneca/node_modules/_gex@0.2.2@gex/node_modules/lodash/internal/baseMergeDeep.js"],"names":["arrayCopy","require","isArguments","isArray","isArrayLike","isPlainObject","isTypedArray","toPlainObject","baseMergeDeep","object","source","key","mergeFunc","customizer","stackA","stackB","length","srcValue","value","result","undefined","isCommon","push","module","exports"],"mappings":";;AAAA,IAAIA,YAAYC,QAAQ,aAAR,CAAhB;AAAA,IACIC,cAAcD,QAAQ,qBAAR,CADlB;AAAA,IAEIE,UAAUF,QAAQ,iBAAR,CAFd;AAAA,IAGIG,cAAcH,QAAQ,eAAR,CAHlB;AAAA,IAIII,gBAAgBJ,QAAQ,uBAAR,CAJpB;AAAA,IAKIK,eAAeL,QAAQ,sBAAR,CALnB;AAAA,IAMIM,gBAAgBN,QAAQ,uBAAR,CANpB;;AAQA;;;;;;;;;;;;;;;AAeA,SAASO,aAAT,CAAuBC,MAAvB,EAA+BC,MAA/B,EAAuCC,GAAvC,EAA4CC,SAA5C,EAAuDC,UAAvD,EAAmEC,MAAnE,EAA2EC,MAA3E,EAAmF;AACjF,MAAIC,SAASF,OAAOE,MAApB;AAAA,MACIC,WAAWP,OAAOC,GAAP,CADf;;AAGA,SAAOK,QAAP,EAAiB;AACf,QAAIF,OAAOE,MAAP,KAAkBC,QAAtB,EAAgC;AAC9BR,aAAOE,GAAP,IAAcI,OAAOC,MAAP,CAAd;AACA;AACD;AACF;AACD,MAAIE,QAAQT,OAAOE,GAAP,CAAZ;AAAA,MACIQ,SAASN,aAAaA,WAAWK,KAAX,EAAkBD,QAAlB,EAA4BN,GAA5B,EAAiCF,MAAjC,EAAyCC,MAAzC,CAAb,GAAgEU,SAD7E;AAAA,MAEIC,WAAWF,WAAWC,SAF1B;;AAIA,MAAIC,QAAJ,EAAc;AACZF,aAASF,QAAT;AACA,QAAIb,YAAYa,QAAZ,MAA0Bd,QAAQc,QAAR,KAAqBX,aAAaW,QAAb,CAA/C,CAAJ,EAA4E;AAC1EE,eAAShB,QAAQe,KAAR,IACLA,KADK,GAEJd,YAAYc,KAAZ,IAAqBlB,UAAUkB,KAAV,CAArB,GAAwC,EAF7C;AAGD,KAJD,MAKK,IAAIb,cAAcY,QAAd,KAA2Bf,YAAYe,QAAZ,CAA/B,EAAsD;AACzDE,eAASjB,YAAYgB,KAAZ,IACLX,cAAcW,KAAd,CADK,GAEJb,cAAca,KAAd,IAAuBA,KAAvB,GAA+B,EAFpC;AAGD,KAJI,MAKA;AACHG,iBAAW,KAAX;AACD;AACF;AACD;AACA;AACAP,SAAOQ,IAAP,CAAYL,QAAZ;AACAF,SAAOO,IAAP,CAAYH,MAAZ;;AAEA,MAAIE,QAAJ,EAAc;AACZ;AACAZ,WAAOE,GAAP,IAAcC,UAAUO,MAAV,EAAkBF,QAAlB,EAA4BJ,UAA5B,EAAwCC,MAAxC,EAAgDC,MAAhD,CAAd;AACD,GAHD,MAGO,IAAII,WAAWA,MAAX,GAAqBA,WAAWD,KAAhC,GAA0CA,UAAUA,KAAxD,EAAgE;AACrET,WAAOE,GAAP,IAAcQ,MAAd;AACD;AACF;;AAEDI,OAAOC,OAAP,GAAiBhB,aAAjB","file":"baseMergeDeep.js","sourcesContent":["var arrayCopy = require('./arrayCopy'),\n    isArguments = require('../lang/isArguments'),\n    isArray = require('../lang/isArray'),\n    isArrayLike = require('./isArrayLike'),\n    isPlainObject = require('../lang/isPlainObject'),\n    isTypedArray = require('../lang/isTypedArray'),\n    toPlainObject = require('../lang/toPlainObject');\n\n/**\n * A specialized version of `baseMerge` for arrays and objects which performs\n * deep merges and tracks traversed objects enabling objects with circular\n * references to be merged.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {string} key The key of the value to merge.\n * @param {Function} mergeFunc The function to merge values.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Array} [stackA=[]] Tracks traversed source objects.\n * @param {Array} [stackB=[]] Associates values with source counterparts.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {\n  var length = stackA.length,\n      srcValue = source[key];\n\n  while (length--) {\n    if (stackA[length] == srcValue) {\n      object[key] = stackB[length];\n      return;\n    }\n  }\n  var value = object[key],\n      result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\n      isCommon = result === undefined;\n\n  if (isCommon) {\n    result = srcValue;\n    if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {\n      result = isArray(value)\n        ? value\n        : (isArrayLike(value) ? arrayCopy(value) : []);\n    }\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n      result = isArguments(value)\n        ? toPlainObject(value)\n        : (isPlainObject(value) ? value : {});\n    }\n    else {\n      isCommon = false;\n    }\n  }\n  // Add the source value to the stack of traversed objects and associate\n  // it with its merged value.\n  stackA.push(srcValue);\n  stackB.push(result);\n\n  if (isCommon) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);\n  } else if (result === result ? (result !== value) : (value === value)) {\n    object[key] = result;\n  }\n}\n\nmodule.exports = baseMergeDeep;\n"]}