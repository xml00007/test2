{"version":3,"sources":["../../../../../../../Seneca/node_modules/_gex@0.2.2@gex/node_modules/lodash/internal/binaryIndexBy.js"],"names":["nativeFloor","Math","floor","nativeMin","min","MAX_ARRAY_LENGTH","MAX_ARRAY_INDEX","binaryIndexBy","array","value","iteratee","retHighest","low","high","length","valIsNaN","valIsNull","valIsUndef","undefined","mid","computed","isDef","isReflexive","setLow","module","exports"],"mappings":";;AAAA;AACA,IAAIA,cAAcC,KAAKC,KAAvB;AAAA,IACIC,YAAYF,KAAKG,GADrB;;AAGA;AACA,IAAIC,mBAAmB,UAAvB;AAAA,IACIC,kBAAkBD,mBAAmB,CADzC;;AAGA;;;;;;;;;;;;;AAaA,SAASE,aAAT,CAAuBC,KAAvB,EAA8BC,KAA9B,EAAqCC,QAArC,EAA+CC,UAA/C,EAA2D;AACzDF,UAAQC,SAASD,KAAT,CAAR;;AAEA,MAAIG,MAAM,CAAV;AAAA,MACIC,OAAOL,QAAQA,MAAMM,MAAd,GAAuB,CADlC;AAAA,MAEIC,WAAWN,UAAUA,KAFzB;AAAA,MAGIO,YAAYP,UAAU,IAH1B;AAAA,MAIIQ,aAAaR,UAAUS,SAJ3B;;AAMA,SAAON,MAAMC,IAAb,EAAmB;AACjB,QAAIM,MAAMnB,YAAY,CAACY,MAAMC,IAAP,IAAe,CAA3B,CAAV;AAAA,QACIO,WAAWV,SAASF,MAAMW,GAAN,CAAT,CADf;AAAA,QAEIE,QAAQD,aAAaF,SAFzB;AAAA,QAGII,cAAcF,aAAaA,QAH/B;;AAKA,QAAIL,QAAJ,EAAc;AACZ,UAAIQ,SAASD,eAAeX,UAA5B;AACD,KAFD,MAEO,IAAIK,SAAJ,EAAe;AACpBO,eAASD,eAAeD,KAAf,KAAyBV,cAAcS,YAAY,IAAnD,CAAT;AACD,KAFM,MAEA,IAAIH,UAAJ,EAAgB;AACrBM,eAASD,gBAAgBX,cAAcU,KAA9B,CAAT;AACD,KAFM,MAEA,IAAID,YAAY,IAAhB,EAAsB;AAC3BG,eAAS,KAAT;AACD,KAFM,MAEA;AACLA,eAASZ,aAAcS,YAAYX,KAA1B,GAAoCW,WAAWX,KAAxD;AACD;AACD,QAAIc,MAAJ,EAAY;AACVX,YAAMO,MAAM,CAAZ;AACD,KAFD,MAEO;AACLN,aAAOM,GAAP;AACD;AACF;AACD,SAAOhB,UAAUU,IAAV,EAAgBP,eAAhB,CAAP;AACD;;AAEDkB,OAAOC,OAAP,GAAiBlB,aAAjB","file":"binaryIndexBy.js","sourcesContent":["/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeFloor = Math.floor,\n    nativeMin = Math.min;\n\n/** Used as references for the maximum length and index of an array. */\nvar MAX_ARRAY_LENGTH = 4294967295,\n    MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1;\n\n/**\n * This function is like `binaryIndex` except that it invokes `iteratee` for\n * `value` and each element of `array` to compute their sort ranking. The\n * iteratee is invoked with one argument; (value).\n *\n * @private\n * @param {Array} array The sorted array to inspect.\n * @param {*} value The value to evaluate.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {boolean} [retHighest] Specify returning the highest qualified index.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n */\nfunction binaryIndexBy(array, value, iteratee, retHighest) {\n  value = iteratee(value);\n\n  var low = 0,\n      high = array ? array.length : 0,\n      valIsNaN = value !== value,\n      valIsNull = value === null,\n      valIsUndef = value === undefined;\n\n  while (low < high) {\n    var mid = nativeFloor((low + high) / 2),\n        computed = iteratee(array[mid]),\n        isDef = computed !== undefined,\n        isReflexive = computed === computed;\n\n    if (valIsNaN) {\n      var setLow = isReflexive || retHighest;\n    } else if (valIsNull) {\n      setLow = isReflexive && isDef && (retHighest || computed != null);\n    } else if (valIsUndef) {\n      setLow = isReflexive && (retHighest || isDef);\n    } else if (computed == null) {\n      setLow = false;\n    } else {\n      setLow = retHighest ? (computed <= value) : (computed < value);\n    }\n    if (setLow) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return nativeMin(high, MAX_ARRAY_INDEX);\n}\n\nmodule.exports = binaryIndexBy;\n"]}