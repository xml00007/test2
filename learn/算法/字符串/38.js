// 字符串的排列

/**
* @param {string} s
* @return {string[]}
*/
var permutation = function (s) {
    const res = new Set()
    const visit = {}
    function dfs(path) {
        if (path.length === s.length) return res.add(path)
        for (let i = 0; i < s.length; i++) {
            if (visit[i]) continue
            visit[i] = true
            dfs(path + s[i])
            visit[i] = false
        }
    }
    dfs('')
    return [...res]
};

// 作者：menteceso
// 链接：https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/solution/javascript-hui-su-fa-by-menteceso/
// 来源：力扣（LeetCode）
// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

console.log(permutation('abc'));

// 回溯法详解：
// 结合ABC这个例子具体描述一下算法流程

// 1） 在第一层，A是第一个未访问的元素，将A添加到输出队列，同时将A标记为红色（已访问）；当前层level = 1，不是最后一层，递归到第二层；

// 2） 在第二层，因为A已经访问过，所以B是第一个未访问过的元素，将B添加到输出队列，同时将B标记为红色（已访问），当前层level = 2，不是最后一层，递归到第三层

// 3）在第三层，因为A, B都已经访问过，所以C是第一个未访问过的元素，将C添加到输出队列，同时将C标记为红色（已访问），当前层level = 3，是最后一层；到达最后一层之后说明找到了一个排列ABC，将该排列输出；到达最后一层之后需要向前一层（第二层）回溯，在回溯之前需要将C标记为未访问，因为C是在当前层（第三层）访问的，而上一层（第二层）并没有访问，因此在回溯到第二层之前各元素的访问状态应该恢复到第二层的初始状态；

// 4）回溯到第二层之后，寻找第二个未访问过元素C，将C添加到输出队列，（注意：这里的C将会覆盖在第 2步中添加到队列的B，因为输出队列中元素的下标是level），同时将C标记为红色（已访问），当前层level = 2，不是最后一层，递归到第三层。

// 5） 此时的第三层第一个未标记的元素是B，将B添加到输出队列，同时将B标记为红色（已访问），当前层为第三层是最后一层；到达最后一层之后说明又找到一个排列ACB，将该排列输出；接着再回溯到第二层，回溯到第二层之前，同样需要将C标记为未访问。

// 6）此时又回溯到第二层，第二层的第二，第三个元素都已经遍历过，即第二层此时不存在未遍历过的元素，此时需要回溯到第一层，同理，回溯到第一层直前，需要将A标记为未访问。

// 7） 此时回溯到第一层，寻找第二个未访问过的元素B，将B添加到输出队列，同时标记B为红色（已访问），下面的步骤和第2步中的做法一致。

// 8）到最后输出了每一个可能的排列。
